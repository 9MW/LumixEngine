diff --git a/src/engine/engine.cpp b/src/engine/engine.cpp
index 011366e9..70a66bba 100644
--- a/src/engine/engine.cpp
+++ b/src/engine/engine.cpp
@@ -13,6 +13,7 @@
 #include "engine/log.h"
 #include "engine/lua_wrapper.h"
 #include "engine/math_utils.h"
+#include "engine/page_allocator.h"
 #include "engine/path.h"
 #include "engine/plugin_manager.h"
 #include "engine/prefab.h"
@@ -1232,6 +1233,7 @@ public:
 
 
 	IAllocator& getAllocator() override { return m_allocator; }
+	PageAllocator& getPageAllocator() override { return m_page_allocator; }
 
 
 	const char* getWorkingDirectory() const override { return m_working_dir; }
@@ -1590,6 +1592,7 @@ public:
 
 private:
 	IAllocator& m_allocator;
+    PageAllocator m_page_allocator;
 
 	FS::FileSystem* m_file_system;
 	FS::MemoryFileDevice* m_mem_file_device;
diff --git a/src/engine/engine.h b/src/engine/engine.h
index 819be80d..84f32e3a 100644
--- a/src/engine/engine.h
+++ b/src/engine/engine.h
@@ -20,6 +20,7 @@ class InputBlob;
 struct IAllocator;
 class InputSystem;
 class OutputBlob;
+class PageAllocator;
 class Path;
 class PathManager;
 class PluginManager;
@@ -56,6 +57,7 @@ public:
 	virtual PluginManager& getPluginManager() = 0;
 	virtual ResourceManagerHub& getResourceManager() = 0;
 	virtual IAllocator& getAllocator() = 0;
+    virtual PageAllocator& getPageAllocator() = 0;
 
 	virtual void startGame(Universe& context) = 0;
 	virtual void stopGame(Universe& context) = 0;
diff --git a/src/engine/job_system.cpp b/src/engine/job_system.cpp
index 519df460..8f3e19d3 100644
--- a/src/engine/job_system.cpp
+++ b/src/engine/job_system.cpp
@@ -492,6 +492,12 @@ bool init(IAllocator& allocator)
 }
 
 
+int getWorkersCount()
+{
+    return g_system->m_workers.size();
+}
+
+
 void shutdown()
 {
 	if (!g_system) return;
diff --git a/src/engine/job_system.h b/src/engine/job_system.h
index 35b8dcd2..d259e147 100644
--- a/src/engine/job_system.h
+++ b/src/engine/job_system.h
@@ -21,6 +21,7 @@ constexpr u32 INVALID_HANDLE = 0xffFFffFF;
 
 LUMIX_ENGINE_API bool init(IAllocator& allocator);
 LUMIX_ENGINE_API void shutdown();
+LUMIX_ENGINE_API int getWorkersCount();
 
 LUMIX_ENGINE_API void enableBackupWorker(bool enable);
 
@@ -33,6 +34,19 @@ LUMIX_ENGINE_API void wait(SignalHandle waitable);
 LUMIX_ENGINE_API inline bool isValid(SignalHandle waitable) { return waitable != INVALID_HANDLE; }
 
 
+template <typename F>
+void runAsJobs(F& f)
+{
+    SignalHandle signal = JobSystem::INVALID_HANDLE;
+    for(int i = 0, c = getWorkersCount(); i < c; ++i) {
+        JobSystem::run(&f, [](void* data){
+            (*(F*)data)();
+        }, &signal);
+    }
+    wait(signal);
+}
+
+
 } // namespace JobSystem
 
 
diff --git a/src/renderer/culling_system.cpp b/src/renderer/culling_system.cpp
index 62ae2786..11f01e4c 100644
--- a/src/renderer/culling_system.cpp
+++ b/src/renderer/culling_system.cpp
@@ -7,14 +7,15 @@
 #include "engine/lumix.h"
 #include "engine/math_utils.h"
 #include "engine/mt/atomic.h"
+#include "engine/page_allocator.h"
 #include "engine/profiler.h"
 #include "engine/simd.h"
 #include <cstring>
-#include <Windows.h>
+
 
 namespace Lumix
 {
-    
+
 
 struct CellIndices
 {
@@ -32,6 +33,18 @@ struct CellIndices
     bool is_big;
 };
 
+
+struct CellIndicesHasher
+{
+	// http://www.beosil.com/download/CollisionDetectionHashing_VMV03.pdf
+	// TODO check collisions
+	static u32 get(const CellIndices& indices) {
+        // TODO indices.is_big, indices.type
+		return (u32)indices.pos.x * 73856093 + (u32)indices.pos.y * 19349663 + (u32)indices.pos.z * 83492791; 
+	}
+};
+
+
 struct alignas(4096) CellPage {
     struct {
         CellPage* next = nullptr;
@@ -41,78 +54,24 @@ struct alignas(4096) CellPage {
         int count = 0;
     } header;
 
-    enum { FOO = sizeof(header) };
-    enum { MAX_COUNT = (16384 - sizeof(header)) / (sizeof(Sphere) + sizeof(EntityPtr)) };
+    enum { MAX_COUNT = (PageAllocator::PAGE_SIZE - sizeof(header)) / (sizeof(Sphere) + sizeof(EntityPtr)) };
 
     Sphere spheres[MAX_COUNT];
     EntityPtr entities[MAX_COUNT];
 };
 
-static_assert(sizeof(CellPage) == 16384);
-
-struct CellIndicesHasher
-{
-	// http://www.beosil.com/download/CollisionDetectionHashing_VMV03.pdf
-	// TODO check collisions
-	static u32 get(const CellIndices& indices) {
-        // TODO indices.is_big, indices.type
-		return (u32)indices.pos.x * 73856093 + (u32)indices.pos.y * 19349663 + (u32)indices.pos.z * 83492791; 
-	}
-};
-
-
-static void doCulling(const Sphere* LUMIX_RESTRICT start,
-	const Sphere* LUMIX_RESTRICT end,
-	const Frustum* LUMIX_RESTRICT frustum,
-	const EntityPtr* LUMIX_RESTRICT sphere_to_entity_map,
-	CullingSystem::Subresults& results)
-{
-	PROFILE_FUNCTION();
-	Profiler::recordInt("objects", int(end - start));
-	const float4 px = f4Load(frustum->xs);
-	const float4 py = f4Load(frustum->ys);
-	const float4 pz = f4Load(frustum->zs);
-	const float4 pd = f4Load(frustum->ds);
-	const float4 px2 = f4Load(&frustum->xs[4]);
-	const float4 py2 = f4Load(&frustum->ys[4]);
-	const float4 pz2 = f4Load(&frustum->zs[4]);
-	const float4 pd2 = f4Load(&frustum->ds[4]);
-	
-	int i = 0;
-	for (const Sphere *sphere = start; sphere <= end; sphere++, ++i)
-	{
-		const float4 cx = f4Splat(sphere->position.x);
-		const float4 cy = f4Splat(sphere->position.y);
-		const float4 cz = f4Splat(sphere->position.z);
-		const float4 r = f4Splat(-sphere->radius);
-
-		float4 t = f4Mul(cx, px);
-		t = f4Add(t, f4Mul(cy, py));
-		t = f4Add(t, f4Mul(cz, pz));
-		t = f4Add(t, pd);
-		t = f4Sub(t, r);
-		if (f4MoveMask(t)) continue;
-
-		t = f4Mul(cx, px2);
-		t = f4Add(t, f4Mul(cy, py2));
-		t = f4Add(t, f4Mul(cz, pz2));
-		t = f4Add(t, pd2);
-		t = f4Sub(t, r);
-		if (f4MoveMask(t)) continue;
-
-		results.push((EntityRef)sphere_to_entity_map[i]);
-	}
-}
+static_assert(sizeof(CellPage) == PageAllocator::PAGE_SIZE);
 
 
 struct CullingSystemImpl final : public CullingSystem
 {
-	CullingSystemImpl(IAllocator& allocator) 
+	CullingSystemImpl(IAllocator& allocator, PageAllocator& page_allocator) 
 		: m_allocator(allocator)
 		, m_cell_map(allocator)
 		, m_entity_to_cell(allocator)
         , m_cells(allocator)
 		, m_cell_size(300.0f)
+        , m_page_allocator(page_allocator)
 	{
 	}
 	
@@ -133,7 +92,7 @@ struct CullingSystemImpl final : public CullingSystem
             return &cell.spheres[count];
         }
 
-        void* mem = VirtualAlloc(nullptr, 16384, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
+        void* mem = m_page_allocator.allocate(true);
         CellPage* new_cell = new (Lumix::NewPlaceholder(), mem) CellPage;
         new_cell->header.origin = cell.header.origin;
         new_cell->header.indices = cell.header.indices;
@@ -156,6 +115,7 @@ struct CullingSystemImpl final : public CullingSystem
 
 	void add(EntityRef entity, u8 type, const DVec3& pos, float radius) override
 	{
+        // TODO reuse free space
 		if(m_entity_to_cell.size() <= entity.index) {
 			m_entity_to_cell.reserve(entity.index);
 			while(m_entity_to_cell.size() <= entity.index) {
@@ -167,7 +127,7 @@ struct CullingSystemImpl final : public CullingSystem
 
 		auto iter = m_cell_map.find(i);
 		if (!iter.isValid()) {
-            void* mem = VirtualAlloc(nullptr, 16384, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
+            void* mem = m_page_allocator.allocate(true);
             CellPage* new_cell = new (Lumix::NewPlaceholder(), mem) CellPage;
             new_cell->header.origin = i.pos * double(m_cell_size);
 			new_cell->header.indices = i;
@@ -197,7 +157,8 @@ struct CullingSystemImpl final : public CullingSystem
             if(cell.header.prev) cell.header.prev->header.next = cell.header.next;
             if(cell.header.next) cell.header.next->header.prev = cell.header.prev;
             m_cells.eraseItemFast(&cell);
-            VirtualFree(&cell, 16384, MEM_RELEASE);
+            cell.~CellPage();
+            m_page_allocator.deallocate(&cell, true);
         }
         else {
             const int idx = int(sphere - cell.spheres);
@@ -272,7 +233,8 @@ struct CullingSystemImpl final : public CullingSystem
             while(iter) {
                 CellPage* tmp = iter;
                 iter = tmp->header.next;
-                VirtualFree(tmp, 16384, MEM_RELEASE);
+                tmp->~CellPage();
+                m_page_allocator.deallocate(tmp, true);
             }
         }
        
@@ -282,73 +244,106 @@ struct CullingSystemImpl final : public CullingSystem
 	}
 
 
-    struct CullJob {
-        CullJob(const CullingSystemImpl& system, const ShiftedFrustum& frustum, Subresults& result) 
-            : system(system)
-            , frustum(frustum)
-            , result(result)
-        {}
+    LUMIX_FORCE_INLINE void doCulling(const CellPage& cell
+        , const Frustum& frustum
+        , PagedEntityList* LUMIX_RESTRICT results
+        , PagedList<PagedEntityList>& list)
+    {
+	    PROFILE_FUNCTION();
+        const Sphere* LUMIX_RESTRICT start = cell.spheres;
+	    const Sphere* LUMIX_RESTRICT end = cell.spheres + cell.header.count;
+        const EntityPtr* LUMIX_RESTRICT sphere_to_entity_map = cell.entities;
+
+	    Profiler::recordInt("objects", cell.header.count);
+	    const float4 px = f4Load(frustum.xs);
+	    const float4 py = f4Load(frustum.ys);
+	    const float4 pz = f4Load(frustum.zs);
+	    const float4 pd = f4Load(frustum.ds);
+	    const float4 px2 = f4Load(&frustum.xs[4]);
+	    const float4 py2 = f4Load(&frustum.ys[4]);
+	    const float4 pz2 = f4Load(&frustum.zs[4]);
+	    const float4 pd2 = f4Load(&frustum.ds[4]);
+        int cursor = results->header.count;
+	
+        int i = 0;
+	    for (const Sphere *sphere = start; sphere < end; ++sphere, ++i) {
+		    const float4 cx = f4Splat(sphere->position.x);
+		    const float4 cy = f4Splat(sphere->position.y);
+		    const float4 cz = f4Splat(sphere->position.z);
+		    const float4 r = f4Splat(-sphere->radius);
+
+		    float4 t = f4Mul(cx, px);
+		    t = f4Add(t, f4Mul(cy, py));
+		    t = f4Add(t, f4Mul(cz, pz));
+		    t = f4Add(t, pd);
+		    t = f4Sub(t, r);
+		    if (f4MoveMask(t)) continue;
+
+		    t = f4Mul(cx, px2);
+		    t = f4Add(t, f4Mul(cy, py2));
+		    t = f4Add(t, f4Mul(cz, pz2));
+		    t = f4Add(t, pd2);
+		    t = f4Sub(t, r);
+		    if (f4MoveMask(t)) continue;
+
+            if(cursor == lengthOf(results->entities)) {
+                results->header.count = cursor;
+                results = list.push();
+                cursor = 0;
+            }
 
+            results->entities[cursor] = (EntityRef)sphere_to_entity_map[i];
+		    ++cursor;
+	    }
+        results->header.count = cursor;
+    }
 
-        static void run(void* data) {
-            ((CullJob*)data)->run();
-        }
 
+    PagedEntityList* cull(const ShiftedFrustum& frustum, u8 type) override
+	{
+		PROFILE_FUNCTION();
+		if (m_cells.empty()) return nullptr;
 
-        void run() {
-            PROFILE_FUNCTION();
-		    const Vec3 v3_cell_size(system.m_cell_size);
-		    const Vec3 v3_2_cell_size(2 * system.m_cell_size);
+		const uint worker_count = MT::getCPUsCount();
+
+        JobSystem::SignalHandle signal = JobSystem::INVALID_HANDLE;
+        volatile i32 cell_idx = 0;
+        PagedList<PagedEntityList> list(m_page_allocator);
+
+        JobSystem::runAsJobs([&](){
+            PROFILE_BLOCK("cull_job");
+		    const Vec3 v3_cell_size(m_cell_size);
+		    const Vec3 v3_2_cell_size(2 * m_cell_size);
+            PagedEntityList* result = list.push();
             for(;;) {
-                const i32 idx = MT::atomicIncrement(cell_idx) - 1;
-                if (idx >= system.m_cells.size()) return;
+                const i32 idx = MT::atomicIncrement(&cell_idx) - 1;
+                if (idx >= m_cells.size()) return;
 
-                CellPage& cell = *system.m_cells[idx];
+                CellPage& cell = *m_cells[idx];
                 if(cell.header.indices.type != type) continue;
 
 			    if (frustum.containsAABB(cell.header.origin + v3_cell_size, -v3_cell_size)) {
-				    const int count = result.size();
-                    result.resize(count + cell.header.count);
-                    memcpy(result.begin() + count, cell.entities, sizeof(cell.entities[0]) * cell.header.count);
+                    int to_cpy = cell.header.count;
+                    int src_offset = 0;
+                    while (to_cpy > 0) {
+                        if(result->header.count == lengthOf(result->entities)) {
+                            result = list.push();
+                        }
+                        const int rem_space = lengthOf(result->entities) - result->header.count;
+                        const int step = Math::minimum(to_cpy, rem_space);
+                        memcpy(result->entities + result->header.count, cell.entities + src_offset, step * sizeof(cell.entities[0]));
+                        src_offset += step;
+                        result->header.count += step;
+                        to_cpy -= step;
+                    }
 			    }
 			    else if (frustum.intersectsAABB(cell.header.origin - v3_cell_size, v3_2_cell_size)) {
-					const Frustum rel_frustum = frustum.getRelative(cell.header.origin);
-                    doCulling(cell.spheres, cell.spheres + cell.header.count, &rel_frustum, cell.entities, result);
+                    doCulling(cell, frustum.getRelative(cell.header.origin), result, list);
 			    }
             }
-        }
-
-
-        const CullingSystemImpl& system;
-        ShiftedFrustum frustum;
-        Subresults& result;
-        u8 type;
-        volatile i32* cell_idx = 0;
-    };
+        });
 
-
-    void cull(const ShiftedFrustum& frustum, u8 type, Results& result) override
-	{
-		PROFILE_FUNCTION();
-		if (m_cells.empty()) return;
-
-		const uint buckets_count = MT::getCPUsCount();
-		while(result.size() < (int)buckets_count) {
-            result.emplace(m_allocator);
-            result.back().reserve(256 * 1024);
-        }
-
-        JobSystem::SignalHandle signal = JobSystem::INVALID_HANDLE;
-        volatile i32 cell_idx = 0;
-
-        CullJob* jobs = (CullJob*)alloca(sizeof(CullJob) * result.size());
-        for(int i = 0; i < result.size(); ++i) {
-            CullJob* job = new (NewPlaceholder(), jobs + i) CullJob(*this, frustum, result[i]);
-            job->cell_idx = &cell_idx;
-            job->type = type;
-            JobSystem::run(job, CullJob::run, &signal);
-        }
-        JobSystem::wait(signal);
+        return list.detach();
 	}
 	
 
@@ -359,6 +354,7 @@ struct CullingSystemImpl final : public CullingSystem
 
 
 	IAllocator& m_allocator;
+    PageAllocator& m_page_allocator;
 	HashMap<CellIndices, CellPage*, CellIndicesHasher> m_cell_map;
     Array<CellPage*> m_cells;
 	Array<Sphere*> m_entity_to_cell;
@@ -367,9 +363,20 @@ struct CullingSystemImpl final : public CullingSystem
 
 
 
-CullingSystem* CullingSystem::create(IAllocator& allocator)
+void PagedEntityList::free(PageAllocator& allocator)
+{
+    PagedEntityList* i = this;
+    while(i) {
+        PagedEntityList* tmp = i;
+        i = i->header.next;
+        allocator.deallocate(tmp, true);
+    }
+}
+
+
+CullingSystem* CullingSystem::create(IAllocator& allocator, PageAllocator& page_allocator)
 {
-	return LUMIX_NEW(allocator, CullingSystemImpl)(allocator);
+	return LUMIX_NEW(allocator, CullingSystemImpl)(allocator, page_allocator);
 }
 
 
diff --git a/src/renderer/culling_system.h b/src/renderer/culling_system.h
index f272a8e1..fb4d3de0 100644
--- a/src/renderer/culling_system.h
+++ b/src/renderer/culling_system.h
@@ -10,26 +10,34 @@ namespace Lumix
 	struct DVec3;
 	struct Frustum;
 	struct IAllocator;
+    class PageAllocator;
 	struct ShiftedFrustum;
 	struct Sphere;
 	struct Vec3;
 
+    struct PagedEntityList {
+        void free(PageAllocator& allocator);
+        
+        struct {
+            PagedEntityList* next = nullptr;
+            int count = 0;
+        } header;
+        EntityRef entities[(16384 - sizeof(header)) / sizeof(EntityRef)];
+    };
 
 	class LUMIX_RENDERER_API CullingSystem
 	{
 	public:
-		using Subresults = Array<EntityRef>;
-		using Results = Array<Subresults>;
 
 		CullingSystem() { }
 		virtual ~CullingSystem() { }
 
-		static CullingSystem* create(IAllocator& allocator);
+		static CullingSystem* create(IAllocator& allocator, PageAllocator& page_allocator);
 		static void destroy(CullingSystem& culling_system);
 
 		virtual void clear() = 0;
 
-		virtual void cull(const ShiftedFrustum& frustum, u8 type, Results& result) = 0;
+		virtual PagedEntityList* cull(const ShiftedFrustum& frustum, u8 type) = 0;
 
 		virtual bool isAdded(EntityRef entity) = 0;
 		virtual void add(EntityRef entity, u8 type, const DVec3& pos, float radius) = 0;
diff --git a/src/renderer/editor/plugins.cpp b/src/renderer/editor/plugins.cpp
index 15e80ca1..5ccd9edb 100644
--- a/src/renderer/editor/plugins.cpp
+++ b/src/renderer/editor/plugins.cpp
@@ -30,6 +30,7 @@
 #include "fbx_importer.h"
 #include "game_view.h"
 #include "renderer/draw2d.h"
+#include "renderer/culling_system.h"
 #include "renderer/ffr/ffr.h"
 #include "renderer/font_manager.h"
 #include "renderer/material.h"
@@ -2175,11 +2176,10 @@ struct RenderInterfaceImpl final : public RenderInterface
 
 	void getRenderables(Array<EntityRef>& entities, const ShiftedFrustum& frustum, RenderableTypes type) override
 	{
-		Array<Array<EntityRef>> renderables(m_render_scene->getAllocator());
-		m_render_scene->getRenderables(frustum, renderables, type);
-		for (const Array<EntityRef>& a : renderables) {
-			for (EntityRef b : a) {
-				entities.push(b);
+		PagedEntityList* renderables = m_render_scene->getRenderables(frustum, type);
+		while (renderables) {
+			for (int i = 0; i < renderables->header.count; ++i) {
+				entities.push(renderables->entities[i]);
 			}
 		}
 	}
diff --git a/src/renderer/pipeline.cpp b/src/renderer/pipeline.cpp
index 8feb1229..d150d391 100644
--- a/src/renderer/pipeline.cpp
+++ b/src/renderer/pipeline.cpp
@@ -13,6 +13,7 @@
 #include "engine/math_utils.h"
 #include "engine/mt/atomic.h"
 #include "engine/mt/sync.h"
+#include "engine/page_allocator.h"
 #include "engine/path.h"
 #include "engine/profiler.h"
 #include "engine/resource_manager.h"
@@ -20,6 +21,7 @@
 #include "engine/timer.h"
 #include "engine/universe/universe.h"
 #include "engine/viewport.h"
+#include "culling_system.h"
 #include "font_manager.h"
 #include "material.h"
 #include "model.h"
@@ -123,13 +125,13 @@ struct MTBucketArray
 		b.array = this;
 		
         // TODO get rid of mutex, atomics should be enough
-		m_mutex.lock();
+		m_mutex.enter();
 		m_counts.emplace();
 		b.values = (T*)m_values_end;
 		b.keys = (T*)m_keys_end;
 		m_keys_end += BUCKET_SIZE;
 		m_values_end += BUCKET_SIZE;
-		m_mutex.unlock();
+		m_mutex.exit();
 		// TODO make sure BUCKET_SIZE is multiple of page size
 		VirtualAlloc(b.values, BUCKET_SIZE, MEM_COMMIT, PAGE_READWRITE);
 		VirtualAlloc(b.keys, BUCKET_SIZE, MEM_COMMIT, PAGE_READWRITE);
@@ -139,7 +141,7 @@ struct MTBucketArray
 	void end(const Bucket& bucket)
 	{
 		const int bucket_idx = int(((u8*)bucket.values - m_values_mem) / BUCKET_SIZE);
-		MT::SpinLock lock(m_mutex);
+		MT::CriticalSectionLock lock(m_mutex);
 		m_counts[bucket_idx] = bucket.count;
 	}
 
@@ -170,7 +172,7 @@ struct MTBucketArray
 	T* key_ptr() const { return (T*)m_keys_mem; }
 	T* value_ptr() const { return (T*)m_values_mem; }
 
-	MT::SpinMutex m_mutex;
+	MT::CriticalSection m_mutex;
 	u8* m_keys_mem;
 	u8* m_values_mem;
 	u8* m_keys_end;
@@ -2501,186 +2503,6 @@ struct PipelineImpl final : Pipeline
 			}
 		}
 
-		struct CreateSortKeys 
-		{
-			static void execute(void* data)
-			{
-				PROFILE_BLOCK("sort_keys");
-				CreateSortKeys* ctx = (CreateSortKeys*)data;
-				Profiler::recordInt("num", ctx->count);
-				const auto* bucket_map = ctx->cmd->m_bucket_map;
-				const SortOrder* bucket_sort_order = ctx->cmd->m_bucket_sort_order;
-				RenderScene* scene = ctx->cmd->m_pipeline->m_scene;
-				const ModelInstance* LUMIX_RESTRICT model_instances = scene->getModelInstances();
-				const EntityRef* LUMIX_RESTRICT renderables = ctx->renderables;
-                MTBucketArray<u64>::Bucket sort_keys = ctx->sort_keys;
-				const Universe::EntityData* LUMIX_RESTRICT entity_data = scene->getUniverse().getEntityData();
-				const DVec3 camera_pos = ctx->camera_params.pos;
-                const u64 type_mask = (u64)ctx->type << 32;
-				switch(ctx->type) {
-					case RenderableTypes::MESH: {
-                        for (int i = 0, c = ctx->count; i < c; ++i) {
-					        const EntityRef e = renderables[i];
-					        const ModelInstance& mi = model_instances[e.index];
-							const Mesh& mesh = mi.meshes[0];
-							const u8 bucket = bucket_map[mesh.layer];
-							const SortOrder sort_order = bucket_sort_order[bucket];
-							if (bucket < 0xff) {
-								const u64 subrenderable = renderables[i].index | type_mask;
-								if (sort_order == SortOrder::DEFAULT) {
-									const u64 key = ((u64)mesh.sort_key << 32) | ((u64)bucket << 56);
-									sort_keys.push(key, subrenderable);
-								}
-								else {
-									const DVec3 pos = entity_data[e.index].transform.pos;
-									const DVec3 rel_pos = pos - camera_pos;
-									const float squared_length = float(rel_pos.x * rel_pos.x + rel_pos.y * rel_pos.y + rel_pos.z * rel_pos.z);
-									const u32 depth_bits = Math::floatFlip(*(u32*)&squared_length);
-									const u64 key = mesh.sort_key | ((u64)bucket << 56) | ((u64)depth_bits << 24);
-									sort_keys.push(key, subrenderable);
-								}
-							}
-                        }
-                        break;
-                    }
-                    case RenderableTypes::SKINNED:
-					case RenderableTypes::MESH_GROUP: {
-                        for (int i = 0, c = ctx->count; i < c; ++i) {
-					        const EntityRef e = renderables[i];
-					        const DVec3 pos = entity_data[e.index].transform.pos;
-					        const ModelInstance& mi = model_instances[e.index];
-							const float squared_length = float((pos - camera_pos).squaredLength());
-							const LODMeshIndices lod = mi.model->getLODMeshIndices(squared_length);
-							for (int mesh_idx = lod.from; mesh_idx <= lod.to; ++mesh_idx) {
-							    // TODO bucket
-                                // TODO type
-                                ASSERT(false);
-                                sort_keys.push(mi.meshes[mesh_idx].sort_key, renderables[i].index | type_mask | ((u64)mesh_idx << 40));
-							}
-						}
-					    break;
-                    }
-                }
-                /*for (int i = 0, c = ctx->count; i < c; ++i) {
-					const EntityRef e = renderables[i];
-					const DVec3 pos = entity_data[e.index].transform.pos;
-					const ModelInstance& mi = model_instances[e.index];
-					const RenderableTypes type = ctx->type;
-					switch (type) {
-						case RenderableTypes::MESH: {
-							const Mesh& mesh = mi.meshes[0];
-							const u8 bucket = bucket_map[mesh.layer];
-							if (bucket < 0xff) {
-								const DVec3 rel_pos = pos - camera_pos;
-								const float squared_length = float(rel_pos.x * rel_pos.x + rel_pos.y * rel_pos.y + rel_pos.z * rel_pos.z);
-								const u32 depth_bits = Math::floatFlip(*(u32*)&squared_length);
-								if(bucket_sort_order[bucket] == SortOrder::DEPTH) {
-									const u64 key = mesh.sort_key | ((u64)bucket << 56) | ((u64)depth_bits << 24);
-									sort_keys.push(key);
-								}
-								else {
-									const u64 key = ((u64)mesh.sort_key << 32) | ((u64)bucket << 56) /*| depth_bits*//*;
-									sort_keys.push(key);
-								}
-								subrenderables.push(renderables[i].index);
-							}
-							break;
-						}
-						case RenderableTypes::SKINNED:
-						case RenderableTypes::MESH_GROUP: {
-								// TODO bucket
-								const float squared_length = float((pos - camera_pos).squaredLength());
-								const LODMeshIndices lod = mi.model->getLODMeshIndices(squared_length);
-								for (int mesh_idx = lod.from; mesh_idx <= lod.to; ++mesh_idx) {
-									sort_keys.push(mi.meshes[mesh_idx].sort_key);
-									subrenderables.push(renderables[i].index | ((u64)mesh_idx << 32));
-								}
-							}
-							break;
-						case RenderableTypes::DECAL: {
-							// TODO camera inside decal volume
-							const Material* material = scene->getDecalMaterial(e);
-							const int layer = material->getLayer();
-							const u8 bucket = bucket_map[layer];
-							if (bucket < 0xff) {
-								// TODO material can have the same sort key as mesh
-								sort_keys.push(material->getSortKey() | ((u64)bucket << 56));
-								subrenderables.push(renderables[i].index);
-							}
-							break;
-						}
-						case RenderableTypes::LOCAL_LIGHT: {
-							if(ctx->local_light_bucket < 0xff) {
-								sort_keys.push(((u64)ctx->local_light_bucket << 56));
-								subrenderables.push(renderables[i].index);
-							}
-							break;
-						}
-						case RenderableTypes::GRASS: {
-							Terrain* t = scene->getTerrain(e);
-							bool should_render = false;
-							for (const Terrain::GrassType& type : t->m_grass_types) {
-								if (!type.m_grass_model || !type.m_grass_model->isReady()) continue;
-
-								for (int mesh_idx = 0; mesh_idx < type.m_grass_model->getMeshCount(); ++mesh_idx) {
-									const Mesh& mesh = type.m_grass_model->getMesh(mesh_idx);
-									if (bucket_map[mesh.layer] < 0xff) {
-										should_render = true;
-										break;
-									}
-								}
-							}
-							if (!should_render) break;
-							if (ctx->camera_params.is_shadow) break;
-
-							// TODO 0 const in following:
-							t->updateGrass(0, ctx->camera_params.pos);
-
-							if (t->m_grass_quads.empty()) break;
-							ASSERT(t->m_grass_quads[0].size() <= 0xffff);
-							u64 quad_idx = 0;
-							// TODO 0 const in following:
-							for (const Terrain::GrassQuad* quad : t->m_grass_quads[0]) {
-								u64 patch_idx = 0;
-								ASSERT(quad->m_patches.size() <= 16);
-								for (const Terrain::GrassPatch& p : quad->m_patches) {
-									if (p.m_type->m_grass_model->isReady()) {
-										const int mesh_count = p.m_type->m_grass_model->getMeshCount();
-										ASSERT(mesh_count <= 256);
-										for (int mesh_idx = 0; mesh_idx < mesh_count; ++mesh_idx) {
-											const Mesh& mesh = p.m_type->m_grass_model->getMesh(mesh_idx);
-											const u8 bucket = bucket_map[mesh.layer];
-											if (bucket < 0xff && !p.instance_data.empty()) {
-												sort_keys.push(((u64)bucket << 56) | mesh.sort_key | ((u64)1 << 55));
-												subrenderables.push(renderables[i].index
-													| (quad_idx << 32)
-													| (patch_idx << 48)
-													| ((u64)mesh_idx << 56)
-												);
-											}
-										}
-									}
-									++patch_idx;
-								}
-								++quad_idx;
-							}
-							break;
-						}
-						default: ASSERT(false); break;
-					}
-				}*/
-				sort_keys.end();
-			}
-
-			MTBucketArray<u64>::Bucket sort_keys;
-			CameraParams camera_params;
-			EntityRef* renderables;
-            RenderableTypes type;
-			u8 local_light_bucket;
-			int count;
-			PrepareCommandsRenderJob* cmd;
-		};
-
 
 		struct CreateCommands 
 		{
@@ -2900,26 +2722,77 @@ struct PipelineImpl final : Pipeline
 		};
 
 
-		void createSortKeys(const Array<Array<EntityRef>>& renderables, RenderableTypes type, MTBucketArray<u64>& sort_keys)
+		void createSortKeys(const PagedEntityList* renderables, RenderableTypes type, MTBucketArray<u64>& sort_keys)
 		{
-			Array<CreateSortKeys> create_sort_keys(m_allocator);
-			create_sort_keys.reserve(renderables.size());
-			JobSystem::SignalHandle counter = JobSystem::INVALID_HANDLE;
-			const u8 local_light_layer = m_pipeline->m_renderer.getLayerIdx("local_light");
+            const u8 local_light_layer = m_pipeline->m_renderer.getLayerIdx("local_light");
 			const u8 local_light_bucket = m_bucket_map[local_light_layer];
-			for(int i = 0; i < renderables.size(); ++i) {
-				if (renderables[i].empty()) continue;
-				CreateSortKeys& ctx = create_sort_keys.emplace();
-				ctx.local_light_bucket = local_light_bucket;
-				ctx.renderables = renderables[i].begin();
-				ctx.sort_keys = sort_keys.begin();
-				ctx.count = renderables[i].size();
-                ctx.type = type;
-				ctx.camera_params = m_camera_params;
-				ctx.cmd = this;
-				JobSystem::run(&ctx, &CreateSortKeys::execute, &counter);
-			}
-			JobSystem::wait(counter);
+			PagedListIterator<const PagedEntityList> iterator(renderables);
+
+            JobSystem::runAsJobs([&](){
+				PROFILE_BLOCK("sort_keys");
+                int total = 0;
+				const auto* bucket_map = m_bucket_map;
+				const SortOrder* bucket_sort_order = m_bucket_sort_order;
+				RenderScene* scene = m_pipeline->m_scene;
+				const ModelInstance* LUMIX_RESTRICT model_instances = scene->getModelInstances();
+                MTBucketArray<u64>::Bucket result = sort_keys.begin();
+				const Universe::EntityData* LUMIX_RESTRICT entity_data = scene->getUniverse().getEntityData();
+				const DVec3 camera_pos = m_camera_params.pos;
+                const u64 type_mask = (u64)type << 32;
+				
+                for(;;) {
+                    const PagedEntityList* page = iterator.next();
+                    if(!page) break;
+                    total += page->header.count;
+                    const EntityRef* LUMIX_RESTRICT renderables = page->entities;
+                    switch(type) {
+					    case RenderableTypes::MESH: {
+                            for (int i = 0, c = page->header.count; i < c; ++i) {
+					            const EntityRef e = renderables[i];
+					            const ModelInstance& mi = model_instances[e.index];
+							    const Mesh& mesh = mi.meshes[0];
+							    const u8 bucket = bucket_map[mesh.layer];
+							    const SortOrder sort_order = bucket_sort_order[bucket];
+							    if (bucket < 0xff) {
+								    const u64 subrenderable = e.index | type_mask;
+								    if (sort_order == SortOrder::DEFAULT) {
+									    const u64 key = ((u64)mesh.sort_key << 32) | ((u64)bucket << 56);
+									    result.push(key, subrenderable);
+								    }
+								    else {
+									    const DVec3 pos = entity_data[e.index].transform.pos;
+									    const DVec3 rel_pos = pos - camera_pos;
+									    const float squared_length = float(rel_pos.x * rel_pos.x + rel_pos.y * rel_pos.y + rel_pos.z * rel_pos.z);
+									    const u32 depth_bits = Math::floatFlip(*(u32*)&squared_length);
+									    const u64 key = mesh.sort_key | ((u64)bucket << 56) | ((u64)depth_bits << 24);
+									    result.push(key, subrenderable);
+								    }
+							    }
+                            }
+                            break;
+                        }
+                        case RenderableTypes::SKINNED:
+					    case RenderableTypes::MESH_GROUP: {
+                            for (int i = 0, c = page->header.count; i < c; ++i) {
+					            const EntityRef e = renderables[i];
+					            const DVec3 pos = entity_data[e.index].transform.pos;
+					            const ModelInstance& mi = model_instances[e.index];
+							    const float squared_length = float((pos - camera_pos).squaredLength());
+							    const LODMeshIndices lod = mi.model->getLODMeshIndices(squared_length);
+							    for (int mesh_idx = lod.from; mesh_idx <= lod.to; ++mesh_idx) {
+							        // TODO bucket
+                                    // TODO type
+                                    ASSERT(false);
+                                    result.push(mi.meshes[mesh_idx].sort_key, e.index | type_mask | ((u64)mesh_idx << 40));
+							    }
+						    }
+					        break;
+                        }
+                    }
+                }
+				result.end();
+                Profiler::recordInt("count", total);
+            });
 		}
 
 
@@ -2930,7 +2803,6 @@ struct PipelineImpl final : Pipeline
 
 			Renderer& renderer = m_pipeline->m_renderer;
 			const RenderScene* scene = m_pipeline->getScene();
-			Array<Array<EntityRef>> renderables(renderer.getAllocator());
 
 			MTBucketArray<u64> sort_keys(m_allocator);
 
@@ -2943,9 +2815,9 @@ struct PipelineImpl final : Pipeline
                 RenderableTypes::LOCAL_LIGHT
             };
             for(RenderableTypes type : types) {
-                for(auto& r : renderables) r.clear();
-                scene->getRenderables(m_camera_params.frustum, renderables, type);
-			    createSortKeys(renderables, type, sort_keys);
+                PagedEntityList* renderables = scene->getRenderables(m_camera_params.frustum, type);
+                createSortKeys(renderables, type, sort_keys);
+                renderables->free(m_pipeline->m_renderer.getEngine().getPageAllocator());
             }
             sort_keys.merge();
 
diff --git a/src/renderer/render_scene.cpp b/src/renderer/render_scene.cpp
index 0d4553bd..2fd26164 100644
--- a/src/renderer/render_scene.cpp
+++ b/src/renderer/render_scene.cpp
@@ -2315,18 +2315,20 @@ bgfx::TextureHandle& handle = pipeline->getRenderbuffer(framebuffer_name, render
 	}
 
 
-	void getRenderables(const ShiftedFrustum& frustum, Array<Array<EntityRef>>& result, RenderableTypes type) const override
+	PagedEntityList* getRenderables(const ShiftedFrustum& frustum, RenderableTypes type) const override
 	{
-		m_culling_system->cull(frustum, static_cast<u8>(type), result);
-
-        if(type == RenderableTypes::GRASS) {
+		PagedEntityList* result = m_culling_system->cull(frustum, static_cast<u8>(type));
+        // TODO
+        //ASSERT(false);
+        return result;
+        /*if(type == RenderableTypes::GRASS) {
             if (m_is_grass_enabled && !m_terrains.empty()) {
 			    if (result.empty()) result.emplace(m_allocator);
 			    for (auto* terrain : m_terrains) {
 				    result[0].push(terrain->m_entity);
 			    }
 		    }
-        }
+        }*/
 	}
 
 
@@ -3739,7 +3741,7 @@ RenderSceneImpl::RenderSceneImpl(Renderer& renderer,
 {
 	m_universe.entityTransformed().bind<RenderSceneImpl, &RenderSceneImpl::onEntityMoved>(this);
 	m_universe.entityDestroyed().bind<RenderSceneImpl, &RenderSceneImpl::onEntityDestroyed>(this);
-	m_culling_system = CullingSystem::create(m_allocator);
+	m_culling_system = CullingSystem::create(m_allocator, engine.getPageAllocator());
 	m_model_instances.reserve(5000);
 
 	MaterialManager& manager = m_renderer.getMaterialManager();
diff --git a/src/renderer/render_scene.h b/src/renderer/render_scene.h
index 3277057a..895ab42d 100644
--- a/src/renderer/render_scene.h
+++ b/src/renderer/render_scene.h
@@ -22,6 +22,7 @@ class LIFOAllocator;
 class Material;
 struct Mesh;
 class Model;
+struct PagedEntityList;
 class Path;
 struct Pose;
 struct RayCastModelHit;
@@ -270,7 +271,7 @@ public:
 	virtual const ModelInstance* getModelInstances() const = 0;
 	virtual Path getModelInstancePath(EntityRef entity) = 0;
 	virtual void setModelInstancePath(EntityRef entity, const Path& path) = 0;
-	virtual void getRenderables(const ShiftedFrustum& frustum, Array<Array<EntityRef>>& result, RenderableTypes type) const = 0;
+	virtual PagedEntityList* getRenderables(const ShiftedFrustum& frustum, RenderableTypes type) const = 0;
 	virtual void getModelInstanceEntities(const ShiftedFrustum& frustum, Array<EntityRef>& entities) = 0;
 	virtual EntityPtr getFirstModelInstance() = 0;
 	virtual EntityPtr getNextModelInstance(EntityPtr entity) = 0;
