include "pipelines/common.glsl"

common [[ 
	layout(std140, binding = 4) uniform Drawcall {
		vec4 u_pos_radius;
	};
]]

------------------

vertex_shader [[
	layout (location = 0) in vec3 a_position;
	layout (location = 0) out vec3 v_uv;
	layout (location = 1) out float v_radius;
	void main()
	{
		v_uv = a_position;
		gl_Position = u_camera_projection * u_camera_view * vec4(a_position * u_pos_radius.w + u_pos_radius.xyz, 1);
	}
]]

---------------------


fragment_shader [[
	layout (location = 0) in vec3 v_uv;
	layout (location = 0) out vec4 o_color;

	layout (binding=0) uniform sampler2D u_gbuffer0;
	layout (binding=1) uniform sampler2D u_gbuffer1;
	layout (binding=2) uniform sampler2D u_gbuffer2;
	layout (binding=3) uniform sampler2D u_gbuffer_depth;
	#ifndef _LUMIX_WEIGHTS
		layout (binding=4) uniform sampler2D u_totalw_map;
	#endif

	void main()
	{
		vec2 screen_uv = gl_FragCoord.xy / u_framebuffer_size;
		vec3 wpos = getViewPosition(u_gbuffer_depth, u_camera_inv_view_projection, screen_uv);
		vec3 d = abs(wpos - u_pos_radius.xyz);
		float alpha = 1 - saturate(max(max(d.x, d.y), d.z) / u_pos_radius.w);

		#ifdef _LUMIX_WEIGHTS
			o_color = vec4(alpha);
		#else
			if (alpha <= 0) discard;
			vec4 gb0 = texture(u_gbuffer0, screen_uv);
			float total_w = texture(u_totalw_map, screen_uv).r;
			vec4 gb1 = texture(u_gbuffer1, screen_uv);
			vec4 gb2 = texture(u_gbuffer2, screen_uv);
			float depth = texture(u_gbuffer_depth, screen_uv).x;

			vec3 albedo = gb0.rgb;
			vec3 normal = gb1.rgb * 2 - 1;
			float roughness = gb0.w;
			float metallic = gb1.w;
			float emission = unpackEmission(gb2.x);

			vec3 V = normalize(-wpos);
			vec3 L = normalize(u_light_direction.xyz);
		
			#ifdef _LUMIX_SPECULAR
				vec3 indirect = PBR_ComputeIndirectSpecular(u_radiancemap, albedo, metallic, roughness, normal, V);
			#else
				vec3 indirect = PBR_ComputeIndirectDiffuse(u_irradiancemap, albedo, metallic, normal, V);
			#endif
			o_color = vec4((indirect * u_light_indirect_intensity) * (alpha / total_w), 1);
		#endif
	}
]]