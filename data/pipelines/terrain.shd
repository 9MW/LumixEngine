include "pipelines/common.glsl"

texture_slot {
	name = "Heightmap",
	default_texture = "textures/common/white.tga"
}

texture_slot {
	name = "Detail albedo",
	default_texture = "textures/common/white.tga"
}

texture_slot {
	name = "Detail normal",
	default_texture = "textures/common/white.tga"
}

texture_slot {
	name = "Splatmap",
	default_texture = "textures/common/white.tga"
}

texture_slot {
	name = "Satellite",
	default_texture = "textures/common/white.tga"
}

texture_slot {
	name = "Noise",
	default_texture = "textures/common/white.tga"
}

uniform("u_detail_distance", "float")
uniform("u_detail_scale", "float")

vertex_shader [[
	out int v_vid;
	
	void main()
	{
		v_vid = gl_VertexID;
	}
]]

common [[
	layout(binding=0) uniform sampler2D u_hm;
	layout(binding=1) uniform sampler2DArray u_albedo;
	layout(binding=2) uniform sampler2DArray u_normal;
	layout(binding=3) uniform sampler2D u_splatmap;
	layout(binding=4) uniform sampler2D u_satellite;
	layout(binding=5) uniform sampler2D u_noise;

	layout(std140, binding = 4) uniform Drawcall {
		ivec4 u_from_to;
		ivec4 u_from_to_sup;
		vec4 u_position;
		vec4 u_rel_camera_pos;
		vec4 u_terrain_scale;
		vec2 u_hm_size;
		float u_cell_size;
	};

	layout (std140, binding = 2) uniform TerrainMaterial {
		vec4 u_material_color_;
		float u_roughness_;
		float u_metallic_;
		float u_emission_;
		float u_detail_distance;
		float u_detail_scale;
	};

	mat3 getTBN(vec2 uv)
	{
		float hscale = u_terrain_scale.y / u_terrain_scale.x;
		ivec3 off = ivec3(-1, 0, 1);
		float s01 = textureLodOffset(u_hm, uv, 0, off.xy).x;
		float s21 = textureLodOffset(u_hm, uv, 0, off.zy).x;
		float s10 = textureLodOffset(u_hm, uv, 0, off.yx).x;
		float s12 = textureLodOffset(u_hm, uv, 0, off.yz).x;
		vec3 va = normalize(vec3(1.0, (s21-s01) * hscale, 0.0));
		vec3 vb = normalize(vec3(0.0, (s12-s10) * hscale, 1.0));
		vec3 N = normalize(cross(vb,va));
		vec3 T = normalize(cross(N, vb));
		return mat3(
			T,
			N,
			normalize(cross(T, N))
		);
	}

	struct Detail {
		vec4 albedo;
		vec3 normal;
	};

	// http://www.iquilezles.org/www/articles/texturerepetition/texturerepetition.htm
	float sum( vec4 v ) { return v.x+v.y+v.z; }

	Detail textureNoTile2(float k, vec2 x, int layer, float v )
	{
		float l = k*8;
		float f = fract(l);
    
		float ia = floor(l);
		float ib = ia + 1.0;
    
		vec2 offa = sin(vec2(3.0,7.0)*ia);
		vec2 offb = sin(vec2(3.0,7.0)*ib);

		vec4 cola = textureLod(u_albedo, vec3(x + v * offa, layer), 0);
		vec4 colb = textureLod(u_albedo, vec3(x + v * offb, layer), 0);

		vec3 norma = textureLod(u_normal, vec3(x + v * offa, layer), 0).xyz * 2 - 1;
		vec3 normb = textureLod(u_normal, vec3(x + v * offb, layer), 0).xyz * 2 - 1;
    
		Detail detail;
		float t = smoothstep(0.2,0.8,f-0.1*sum(cola-colb));
		detail.albedo = mix(cola, colb, t);
		detail.normal = mix(norma, normb, t);
		return detail;
	}

	Detail getDetail(vec2 uv_global, vec2 uv_detail) {
		// TODO one noise texture
		float r = texture(u_noise, uv_global * 256).x * 2 - 1;
		float r2 = texture(u_noise, uv_global.yx * 256).x * 0.6 - 0.3;
		uv_global += vec2(r, r2) / u_hm_size;

		vec2 uv = uv_global * u_hm_size + vec2(0.5);
		vec2 xy = floor(uv);
		vec2 uv_ratio = uv - xy;
		uv_ratio = pow(uv_ratio, vec2(16));
		vec2 uv_opposite = 1.0 - uv_ratio;

		vec4 bicoef = vec4(
			uv_opposite.x * uv_opposite.y,
			uv_opposite.x * uv_ratio.y,
			uv_ratio.x * uv_opposite.y,
			uv_ratio.x * uv_ratio.y
		);

		vec2 half_texel = vec2(0.5) / u_hm_size;

		vec4 splat00 = textureLodOffset(u_splatmap, uv_global - half_texel, 0, ivec2(0, 0));
		vec4 splat10 = textureLodOffset(u_splatmap, uv_global - half_texel, 0, ivec2(1, 0));
		vec4 splat01 = textureLodOffset(u_splatmap, uv_global - half_texel, 0, ivec2(0, 1));
		vec4 splat11 = textureLodOffset(u_splatmap, uv_global - half_texel, 0, ivec2(1, 1));

		float noise = texture(u_noise, 0.1 * uv_global * u_hm_size).x;

		Detail c00 = textureNoTile2(noise, uv_detail, int(splat00.x * 256.0), 1);
		Detail c01 = textureNoTile2(noise, uv_detail, int(splat01.x * 256.0), 1);
		Detail c10 = textureNoTile2(noise, uv_detail, int(splat10.x * 256.0), 1);
		Detail c11 = textureNoTile2(noise, uv_detail, int(splat11.x * 256.0), 1);
			
		Detail res;
		res.normal = normalize(getTBN(uv_global) * (c00.normal * bicoef.x + c01.normal * bicoef.y + c10.normal * bicoef.z + c11.normal * bicoef.w).xzy);
		res.albedo = c00.albedo * bicoef.x + c01.albedo * bicoef.y + c10.albedo * bicoef.z + c11.albedo * bicoef.w;
		return res;
	}
]]

geometry_shader [[
	layout (points) in;
	layout (triangle_strip, max_vertices = 4) out;
	in int v_vid[];
	
	out vec2 v_uv;
	out vec2 v_uv_detail;
	out float v_dist2;

	void getVertex(ivec2 ij, out vec3 pos, out vec2 uv)
	{
		float s = u_cell_size;
		pos = vec3(ij.x, 0.0, ij.y) * s;
		int mask = u_cell_size < 1/8.f ? ~3 : ~1;
		vec3 npos = vec3(ij.x & mask, 0.0, ij.y & mask) * s;

		vec2 size = vec2(u_from_to_sup.zw - u_from_to_sup.xy);
		vec2 rel = (ij - u_from_to_sup.xy) / size;
		
		rel = saturate(abs(rel - vec2(0.5)) * 10 - 4);
	
		pos.xz = mix(pos.xz, npos.xz, rel.yx);
		uv = (pos.xz + vec2(0.5 * u_terrain_scale.xz)) / u_hm_size;
		//pos.xz *= u_terrain_scale.xz;
	}
	
	void main()
	{
		ivec2 size = u_from_to.zw - u_from_to.xy;
	
		ivec2 ij = ivec2(
			u_from_to.x + v_vid[0] % size.x,
			u_from_to.y + v_vid[0] / size.x
		);
	
		float s = u_cell_size;
		float hscale = u_terrain_scale.y;
			

		// because of float precision
		vec2 detail_uv_offset = floor(u_rel_camera_pos.xz);


		vec3 v;
		getVertex(ij, v, v_uv);
		v_uv_detail = u_detail_scale * v_uv * u_hm_size - detail_uv_offset;
		float h = texture(u_hm, v_uv).x * hscale;

		if (s < 0.5) {
			Detail d = getDetail(v_uv, v_uv_detail);
			float dist = max(0, length(vec4(u_position.xyz + v + vec3(0, h, 0), 1)) - 4);
			const float detail_h_scale = 0.3 * saturate(1 - dist / 3);
			h += d.albedo.a * detail_h_scale - detail_h_scale * 0.5;
		}
		vec4 p = u_pass_view * vec4(u_position.xyz + v + vec3(0, h, 0), 1);
		v_dist2 = dot(p.xyz, p.xyz);
		gl_Position = u_pass_projection * p;
		EmitVertex();

		getVertex(ij + ivec2(1, 0), v, v_uv);
		v_uv_detail = u_detail_scale * v_uv * u_hm_size - detail_uv_offset;
		h = texture(u_hm, v_uv).x * hscale;
		if (s < 0.5) {
			Detail d = getDetail(v_uv, v_uv_detail);
			float dist = max(0, length(vec4(u_position.xyz + v + vec3(0, h, 0), 1)) - 4);
			const float detail_h_scale = 0.3 * saturate(1 - dist / 3);
			h += d.albedo.a * detail_h_scale - detail_h_scale * 0.5;
		}
		p = u_pass_view * vec4(u_position.xyz + v + vec3(0, h, 0), 1);
		v_dist2 = dot(p.xyz, p.xyz);
		gl_Position = u_pass_projection * p;
		EmitVertex();

		getVertex(ij + ivec2(0, 1), v, v_uv);
		v_uv_detail = u_detail_scale * v_uv * u_hm_size - detail_uv_offset;
		h = texture(u_hm, v_uv).x * hscale;
		if (s < 0.5) {
			Detail d = getDetail(v_uv, v_uv_detail);
			float dist = max(0, length(vec4(u_position.xyz + v + vec3(0, h, 0), 1)) - 4);
			const float detail_h_scale = 0.3 * saturate(1 - dist / 3);
			h += d.albedo.a * detail_h_scale - detail_h_scale * 0.5;
		}
		p = u_pass_view * vec4(u_position.xyz + v + vec3(0, h, 0), 1);
		v_dist2 = dot(p.xyz, p.xyz);
		gl_Position = u_pass_projection * p;
		EmitVertex();

		getVertex(ij + ivec2(1, 1), v, v_uv);
		v_uv_detail = u_detail_scale * v_uv * u_hm_size - detail_uv_offset;
		h = texture(u_hm, v_uv).x * hscale;
		if (s < 0.5) {
			Detail d = getDetail(v_uv, v_uv_detail);
			float dist = max(0, length(vec4(u_position.xyz + v + vec3(0, h, 0), 1)) - 4);
			const float detail_h_scale = 0.3 * saturate(1 - dist / 3);
			h += d.albedo.a * detail_h_scale - detail_h_scale * 0.5;
		}
		p = u_pass_view * vec4(u_position.xyz + v + vec3(0, h, 0), 1);
		v_dist2 = dot(p.xyz, p.xyz);
		gl_Position = u_pass_projection * p;
		EmitVertex();
	}
]]


fragment_shader [[
	#ifdef DEFERRED
		layout(location = 0) out vec4 o_gbuffer0;
		layout(location = 1) out vec4 o_gbuffer1;
		layout(location = 2) out vec4 o_gbuffer2;
	#else
		layout(location = 0) out vec4 o_color;
	#endif

	in vec2 v_uv;
	in vec2 v_uv_detail;
	in float v_dist2;
	
	Detail textureNoTile(float k, vec2 x, int layer, float v )
	{
		vec2 duvdx = dFdx( x );
		vec2 duvdy = dFdx( x );
    
		float l = k*8;
		float f = fract(l);
    
		float ia = floor(l);
		float ib = ia + 1.0;
    
		vec2 offa = sin(vec2(3.0,7.0)*ia);
		vec2 offb = sin(vec2(3.0,7.0)*ib);

		vec4 cola = textureGrad(u_albedo, vec3(x + v * offa, layer), duvdx, duvdy);
		vec4 colb = textureGrad(u_albedo, vec3(x + v * offb, layer), duvdx, duvdy);

		vec3 norma = textureGrad(u_normal, vec3(x + v * offa, layer), duvdx, duvdy).xyz * 2 - 1;
		vec3 normb = textureGrad(u_normal, vec3(x + v * offb, layer), duvdx, duvdy).xyz * 2 - 1;
    
		Detail detail;
		float t = smoothstep(0.2,0.8,f-0.1*sum(cola-colb));
		detail.albedo = mix(cola, colb, t);
		detail.normal = mix(norma, normb, t);
		return detail;
	}

	void getData()
	{
		if(v_dist2 < u_detail_distance * u_detail_distance) {
			vec2 uvx = v_uv;

			float r = texture(u_noise, uvx*256).x * 2 - 1;
			float r2 = texture(u_noise, uvx.yx*256).x * 0.6 - 0.3;
			uvx += vec2(r, r2) / u_hm_size;

			vec2 uv = uvx * u_hm_size + vec2(0.5);
			vec2 xy = floor(uv);
			vec2 uv_ratio = uv - xy;
			uv_ratio = pow(uv_ratio, vec2(16));
			vec2 uv_opposite = 1.0 - uv_ratio;

			vec4 bicoef = vec4(
				uv_opposite.x * uv_opposite.y,
				uv_opposite.x * uv_ratio.y,
				uv_ratio.x * uv_opposite.y,
				uv_ratio.x * uv_ratio.y
			);

			vec2 half_texel = vec2(0.5) / u_hm_size;

			vec4 splat00 = textureLodOffset(u_splatmap, uvx - half_texel, 0, ivec2(0, 0));
			vec4 splat10 = textureLodOffset(u_splatmap, uvx - half_texel, 0, ivec2(1, 0));
			vec4 splat01 = textureLodOffset(u_splatmap, uvx - half_texel, 0, ivec2(0, 1));
			vec4 splat11 = textureLodOffset(u_splatmap, uvx - half_texel, 0, ivec2(1, 1));

			float noise = texture(u_noise, 0.1 * v_uv * u_hm_size).x;

			Detail c00 = textureNoTile(noise, v_uv_detail, int(splat00.x * 256.0), 1);
			Detail c01 = textureNoTile(noise, v_uv_detail, int(splat01.x * 256.0), 1);
			Detail c10 = textureNoTile(noise, v_uv_detail, int(splat10.x * 256.0), 1);
			Detail c11 = textureNoTile(noise, v_uv_detail, int(splat11.x * 256.0), 1);
			
			data.normal = normalize(getTBN(v_uv) * (c00.normal * bicoef.x + c01.normal * bicoef.y + c10.normal * bicoef.z + c11.normal * bicoef.w).xzy);
			data.albedo.rgb = (c00.albedo * bicoef.x + c01.albedo * bicoef.y + c10.albedo * bicoef.z + c11.albedo * bicoef.w).rgb;
			data.albedo.w = 1;
		}
		else {
			data.normal = getTBN(v_uv)[1];
			data.albedo = texture(u_satellite, vec3(v_uv, 0).xy);
		}
		data.wpos = vec3(0);
		data.roughness = 0.9;
		data.metallic  = 0;
		data.emission = 0;
	}
	
	void main()
	{
		#ifdef DEPTH
			o_color = vec4(shadowmapValue(gl_FragCoord.z));
		#elif defined DEFERRED
			getData();
			o_gbuffer0 = vec4(data.albedo.rgb, data.roughness);
			o_gbuffer1 = vec4(data.normal * 0.5 + 0.5, data.metallic);
			o_gbuffer2 = vec4(data.emission, 0, 0, 1);
		#else 
			o_color.rgb = vec3(1, 0, 1);
			o_color.w = 1;
		#endif
	}
]]